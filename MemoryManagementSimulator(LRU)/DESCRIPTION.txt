Реалізація концепції LRU cache для Memory Management Simulator
Для перевірки роботи LRUCache структури даних використовувався ресурс - https://leetcode.com/problems/lru-cache/

Зміни:
1. class LRUCache - містить множину <ключ,значення> 
(Достатньо було зберігати лише ключі, але я реалізував в більш загальному випадку. Змінити з map на set просто)
put(int,int), get(int) - O(1) complexity on average
Досягається за рахунок реалізації через hash-table і double-linked list.
Hash-table відображає ключі на елементи списку, список зберігає <ключ, значення>.
За рахунок Hash-Table пошук елементу за O(1), за рахунок double-linked list видалення, update за O(1).
getFirstEntry() - повертає індекс lru елемента.

Доданий клас my_implementation.LRUCache використовується для зберігання індексів сторінок з вектору, що знаходяться зараз в "кеші"(
пам'яті швидкого доступу), тобто мають встановлене поле physical != -1.

2. Додана перегрузка(в термінах С++) методу PageFault.replacePage з новим параметром LRUCache
Ми могли реалізувати LRU cache data structure значно простіше через LinkedHashMap, але нам треба дізнаватися lru
елемент за O(1), щоб змінити, наприклад, UI, тому була прописана своя структура даних.
Так, я знаю, що Apache Commons Collections має LinkedMap, що надає необхідний інтерфейс firstKey, lastKey; але ідея була в тому, щоб
показати, що я можу це реалізувати сам.

3. Kernel
Мінімальні зміни, додане поле LRUCache cache, додані виклики методів put,set в Kernel::step(...), Kernel::init(...)
Згоден, що виконання деяких операцій тепер стало лишніми в Kernel, але я поставив собі задачу імпортувати LRUCache в існуючу
архітектуру, а не переписувати архітектуру на кращу. Тому не змінював ці рядки. Якщо треба, то при обоговоренні зможу вказати
на недоліки і що хотів би змінити.

4. змінені файли commands, memory.conf.
В останньому adressradix, pagesize, можливо ще щось




